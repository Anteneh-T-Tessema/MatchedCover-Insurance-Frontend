#!/usr/bin/env node

import { EnhancedInputValidator } from '../../utils/enhanced-input-validation';
import { EnhancedErrorHandler } from '../../utils/enhanced-error-handling';
import { 
  QualityTest,
  QualityReport,
  QualityMetrics,
  CategoryValidation,
  FeatureValidation,
  SecurityCheck,
  SecurityAuditResult,
  PerformanceTest,
  PerformanceReport
} from '../../types/platform-types';

import * as fs from 'fs';
import * as path from 'path';
import { GoogleGenerativeAI } from '@google/generative-ai';
import * as dotenv from 'dotenv';

// Load environment variables
dotenv.config({ path: '.env.soc2-agents' });

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.NEXT_PUBLIC_GEMINI_API_KEY || process.env.GEMINI_API_KEY || '');
const model = genAI.getGenerativeModel({ model: process.env.NEXT_PUBLIC_GEMINI_MODEL || process.env.GEMINI_MODEL || 'gemini-2.0-flash-exp' });

/**
 * Quality Assurance Evaluation Agent
 * Performs comprehensive quality checks on code, features, and implementation
 */
class QualityAssuranceAgent {
  private validator: EnhancedInputValidator = EnhancedInputValidator.getInstance();
  private errorHandler: EnhancedErrorHandler = EnhancedErrorHandler.getInstance();
  private outputDir: string;
  
  constructor() {
    this.outputDir = path.join(process.cwd(), 'qa-output');
    
    // Ensure output directory exists
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }

  /**
   * Main entry point for quality assurance testing
   */
  async runCodeQualityTests(): Promise<QualityReport> {
    try {
      console.log('üîç Running comprehensive quality assurance tests...');

      // Gather all quality tests
      const tests: QualityTest[] = [];
      
      // TypeScript Quality Tests
      tests.push(...await this.runTypeScriptQualityTests());
      
      // Code Structure Tests
      tests.push(...await this.runCodeStructureTests());
      
      // Documentation Tests
      tests.push(...await this.runDocumentationTests());
      
      // Security Tests
      tests.push(...await this.runSecurityTests());
      
      // Performance Tests
      tests.push(...await this.runPerformanceTests());

      // Calculate overall score and generate report
      const qualityReport: QualityReport = {
        timestamp: new Date().toISOString(),
        overallScore: this.calculateOverallScore(tests),
        tests: tests,
        recommendations: await this.generateQualityRecommendations(tests),
        metrics: this.calculateQualityMetrics(tests),
        benchmarks: this.generateQualityBenchmarks(tests)
      };

      // Save the quality report
      await this.saveQualityReport(qualityReport);

      return qualityReport;
    } catch (error) {
      this.errorHandler.handleError(error as Error, {
        context: 'QualityAssuranceAgent.runCodeQualityTests',
        category: 'QUALITY_TEST_ERROR'
      });
      throw error;
    }
  }

  /**
   * Validate feature completeness across different categories
   */
  async validateFeatureCompleteness(): Promise<FeatureValidation> {
    try {
      console.log('üìã Validating feature completeness...');

      const featureCategories = [
        'core_agents',
        'monitoring_system', 
        'compliance_validation',
        'security_controls',
        'audit_preparation'
      ];

      const categoryValidations: CategoryValidation[] = [];

      for (const category of featureCategories) {
        const validation = await this.validateFeatureCategory(category);
        categoryValidations.push(validation);
      }

      const featureValidation: FeatureValidation = {
        timestamp: new Date().toISOString(),
        overallCompleteness: this.calculateOverallCompleteness(categoryValidations),
        categoryValidations: categoryValidations,
        missingFeatures: this.identifyMissingFeatures(categoryValidations),
        implementationGaps: this.identifyImplementationGaps(categoryValidations)
      };

      // Save feature validation results
      await this.saveFeatureValidation(featureValidation);

      return featureValidation;
    } catch (error) {
      this.errorHandler.handleError(error as Error, {
        context: 'QualityAssuranceAgent.validateFeatureCompleteness',
        category: 'FEATURE_VALIDATION_ERROR'
      });
      throw error;
    }
  }

  /**
   * Perform comprehensive security audit
   */
  async performSecurityAudit(): Promise<SecurityAuditResult> {
    try {
      console.log('üîí Performing security audit...');

      const securityChecks: SecurityCheck[] = [];
      
      // API Security checks
      securityChecks.push(...await this.runAPISecurityChecks());
      
      // Data Protection checks  
      securityChecks.push(...await this.runDataProtectionChecks());
      
      // Access Control checks
      securityChecks.push(...await this.runAccessControlChecks());
      
      // Vulnerability checks
      securityChecks.push(...await this.runVulnerabilityChecks());

      const securityAudit: SecurityAuditResult = {
        timestamp: new Date().toISOString(),
        overallSecurityScore: this.calculateSecurityScore(securityChecks),
        checks: securityChecks,
        vulnerabilities: this.identifyVulnerabilities(securityChecks),
        recommendations: await this.generateSecurityRecommendations(securityChecks)
      };

      // Save security audit results
      await this.saveSecurityAudit(securityAudit);

      return securityAudit;
    } catch (error) {
      this.errorHandler.handleError(error as Error, {
        context: 'QualityAssuranceAgent.performSecurityAudit',
        category: 'SECURITY_AUDIT_ERROR'
      });
      throw error;
    }
  }

  /**
   * Check performance metrics and benchmarks
   */
  async checkPerformanceMetrics(): Promise<PerformanceReport> {
    try {
      console.log('‚ö° Checking performance metrics...');

      const performanceTests: PerformanceTest[] = [];
      
      // Agent performance tests
      performanceTests.push(...await this.runAgentPerformanceTests());
      
      // Memory usage tests
      performanceTests.push(...await this.runMemoryUsageTests());
      
      // Scalability tests
      performanceTests.push(...await this.runScalabilityTests());
      
      // Response time tests
      performanceTests.push(...await this.runResponseTimeTests());

      const performanceReport: PerformanceReport = {
        timestamp: new Date().toISOString(),
        overallPerformanceScore: this.calculatePerformanceScore(performanceTests),
        tests: performanceTests,
        benchmarks: this.generatePerformanceBenchmarks(performanceTests),
        optimizationOpportunities: this.identifyOptimizationOpportunities(performanceTests)
      };

      // Save performance report
      await this.savePerformanceReport(performanceReport);

      return performanceReport;
    } catch (error) {
      this.errorHandler.handleError(error as Error, {
        context: 'QualityAssuranceAgent.checkPerformanceMetrics',
        category: 'PERFORMANCE_CHECK_ERROR'
      });
      throw error;
    }
  }

  // TypeScript Quality Tests
  private async runTypeScriptQualityTests(): Promise<QualityTest[]> {
    const tests: QualityTest[] = [];

    // Check TypeScript configuration
    tests.push(await this.checkTypeScriptConfiguration());
    
    // Check type coverage
    tests.push(await this.checkTypeCoverage());
    
    // Check for any types
    tests.push(await this.checkForAnyTypes());
    
    // Check interface consistency
    tests.push(await this.checkInterfaceConsistency());

    return tests;
  }

  private async checkTypeScriptConfiguration(): Promise<QualityTest> {
    const tsconfigPath = path.join(process.cwd(), 'tsconfig.soc2.json');
    const exists = fs.existsSync(tsconfigPath);
    
    if (!exists) {
      return {
        id: 'typescript-config',
        name: 'TypeScript Configuration',
        category: 'typescript',
        passed: false,
        score: 0,
        message: 'TypeScript configuration file not found'
      };
    }

    try {
      const config = JSON.parse(fs.readFileSync(tsconfigPath, 'utf8'));
      
      const hasStrictMode = config.compilerOptions?.strict === true;
      const hasStrictNullChecks = config.compilerOptions?.strictNullChecks !== false;
      const hasNoImplicitAny = config.compilerOptions?.noImplicitAny !== false;
      
      const score = (hasStrictMode ? 40 : 0) + (hasStrictNullChecks ? 30 : 0) + (hasNoImplicitAny ? 30 : 0);
      
      return {
        id: 'typescript-config',
        name: 'TypeScript Configuration',
        category: 'typescript',
        passed: score >= 70,
        score: score,
        message: `TypeScript configuration score: ${score}% (strict: ${hasStrictMode}, strictNullChecks: ${hasStrictNullChecks}, noImplicitAny: ${hasNoImplicitAny})`
      };
    } catch (error) {
      return {
        id: 'typescript-config',
        name: 'TypeScript Configuration',
        category: 'typescript',
        passed: false,
        score: 0,
        message: 'Error parsing TypeScript configuration'
      };
    }
  }

  private async checkTypeCoverage(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    
    if (!fs.existsSync(srcDir)) {
      return {
        id: 'type-coverage',
        name: 'Type Coverage',
        category: 'typescript',
        passed: false,
        score: 0,
        message: 'Source directory not found'
      };
    }

    const tsFiles = this.findTypeScriptFiles(srcDir);
    let totalLines = 0;
    let typedLines = 0;

    for (const file of tsFiles) {
      const content = fs.readFileSync(file, 'utf8');
      const lines = content.split('\n');
      
      for (const line of lines) {
        totalLines++;
        if (
          line.includes('interface ') ||
          line.includes('type ') ||
          line.includes('<') && line.includes('>')
        ) {
          typedLines++;
        }
      }
    }

    const coverage = totalLines > 0 ? Math.round((typedLines / totalLines) * 100) : 0;
    
    return {
      id: 'type-coverage',
      name: 'Type Coverage',
      category: 'typescript',
      passed: coverage >= 60,
      score: coverage,
      message: `Type coverage: ${coverage}% (${typedLines}/${totalLines} lines)`
    };
  }

  private async checkForAnyTypes(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    const tsFiles = this.findTypeScriptFiles(srcDir);
    let totalLines = 0;
    let anyTypesFound = 0;

    for (const file of tsFiles) {
      const content = fs.readFileSync(file, 'utf8');
      const lines = content.split('\n');
      
      for (const line of lines) {
        totalLines++;
        if (
          line.includes('<any>') ||
          line.includes('any[]')
        ) {
          anyTypesFound++;
        }
      }
    }

    const anyTypePercentage = totalLines > 0 ? Math.round((anyTypesFound / totalLines) * 100) : 0;
    const score = Math.max(0, 100 - (anyTypePercentage * 10));
    
    return {
      id: 'any-types',
      name: 'Any Types Usage',
      category: 'typescript',
      passed: score >= 80,
      score: score,
      message: `Found ${anyTypesFound} any types in ${totalLines} lines (${anyTypePercentage}%)`
    };
  }

  private async checkInterfaceConsistency(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    const tsFiles = this.findTypeScriptFiles(srcDir);
    let interfaces: string[] = [];
    let inconsistencies = 0;

    for (const file of tsFiles) {
      const content = fs.readFileSync(file, 'utf8');
      
      // Find interfaces
      const interfaceMatches = content.match(/interface\s+(\w+)/g);
      if (interfaceMatches) {
        interfaces.push(...interfaceMatches.map(match => match.split(' ')[1]));
      }
      
      // Check for naming inconsistencies
      const badNaming = content.match(/interface\s+[a-z]/g);
      if (badNaming) {
        inconsistencies += badNaming.length;
      }
    }

    const uniqueInterfaces = new Set(interfaces);
    const duplicates = interfaces.length - uniqueInterfaces.size;
    const totalIssues = duplicates + inconsistencies;
    
    const score = Math.max(0, 100 - (totalIssues * 10));
    
    return {
      id: 'interface-consistency',
      name: 'Interface Consistency',
      category: 'typescript',
      passed: score >= 80,
      score: score,
      message: `Found ${totalIssues} interface issues (${duplicates} duplicates, ${inconsistencies} naming issues)`
    };
  }

  // Code Structure Tests
  private async runCodeStructureTests(): Promise<QualityTest[]> {
    const tests: QualityTest[] = [];

    tests.push(await this.checkDirectoryStructure());
    tests.push(await this.checkFileNamingConventions());
    tests.push(await this.checkCodeOrganization());
    tests.push(await this.checkDependencyManagement());

    return tests;
  }

  private async checkDirectoryStructure(): Promise<QualityTest> {
    const expectedDirs = ['src', 'src/agents', 'src/types', 'src/utils'];
    const missingDirs = expectedDirs.filter(dir => 
      !fs.existsSync(path.join(process.cwd(), dir))
    );
    
    const score = Math.round(((expectedDirs.length - missingDirs.length) / expectedDirs.length) * 100);
    
    return {
      id: 'directory-structure',
      name: 'Directory Structure',
      category: 'structure',
      passed: missingDirs.length === 0,
      score: score,
      message: missingDirs.length > 0 ? `Missing directories: ${missingDirs.join(', ')}` : 'All expected directories found'
    };
  }

  private async checkFileNamingConventions(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    
    if (!fs.existsSync(srcDir)) {
      return {
        id: 'file-naming',
        name: 'File Naming Conventions',
        category: 'structure',
        passed: false,
        score: 0,
        message: 'Source directory not found'
      };
    }

    const tsFiles = this.findTypeScriptFiles(srcDir);
    let conventionViolations = 0;

    for (const file of tsFiles) {
      const fileName = path.basename(file, '.ts');
      
      // Check if it's an Agent/Engine/Manager file (should be PascalCase)
      if (fileName.includes('Agent') || fileName.includes('Engine') || fileName.includes('Manager')) {
        if (!/^[A-Z][a-zA-Z]*$/.test(fileName)) {
          conventionViolations++;
        }
      }
      
      // Check if it's a utility file (should be camelCase or kebab-case)
      if (fileName.includes('util') || fileName.includes('helper')) {
        if (!/^[a-z][a-zA-Z]*$/.test(fileName)) {
          conventionViolations++;
        }
      }
    }
    
    const score = Math.max(0, 100 - (conventionViolations * 5));
    
    return {
      id: 'file-naming',
      name: 'File Naming Conventions',
      category: 'structure',
      passed: conventionViolations === 0,
      score: score,
      message: `Found ${conventionViolations} naming convention violations`
    };
  }

  private async checkCodeOrganization(): Promise<QualityTest> {
    const agentsDir = path.join(process.cwd(), 'src', 'agents');
    
    if (!fs.existsSync(agentsDir)) {
      return {
        id: 'code-organization',
        name: 'Code Organization',
        category: 'structure',
        passed: false,
        score: 0,
        message: 'Agents directory not found'
      };
    }

    const agentFiles = fs.readdirSync(agentsDir)
      .filter(file => file.endsWith('.ts'))
      .filter(file => file.includes('Agent'));

    let wellOrganizedAgents = 0;

    for (const agentFile of agentFiles) {
      const content = fs.readFileSync(path.join(agentsDir, agentFile), 'utf8');
      
      // Check for class structure
      const hasClass = content.includes('class ');
      const hasConstructor = content.includes('constructor(');
      const hasPublicMethods = content.includes('async ') || content.includes('public ');
      
      if (hasClass && hasConstructor && hasPublicMethods) {
        wellOrganizedAgents++;
      }
    }
    
    const score = agentFiles.length > 0 ? Math.round((wellOrganizedAgents / agentFiles.length) * 100) : 0;
    
    return {
      id: 'code-organization',
      name: 'Code Organization',
      category: 'structure',
      passed: score >= 80,
      score: score,
      message: `${wellOrganizedAgents}/${agentFiles.length} agents are well-organized`
    };
  }

  private async checkDependencyManagement(): Promise<QualityTest> {
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    
    if (!fs.existsSync(packageJsonPath)) {
      return {
        id: 'dependency-management',
        name: 'Dependency Management',
        category: 'structure',
        passed: false,
        score: 0,
        message: 'package.json not found'
      };
    }

    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      
      const dependencies = packageJson.dependencies || {};
      const devDependencies = packageJson.devDependencies || {};
      const scripts = packageJson.scripts || {};
      
      const hasRequiredDeps = Boolean(
        dependencies['dotenv']
      );
      const hasDevDeps = Boolean(
        devDependencies['ts-node']
      );
      const hasScripts = Boolean(
        scripts['test-enhanced']
      );
      
      let score = 0;
      if (hasRequiredDeps) score += 40;
      if (hasDevDeps) score += 30;
      if (hasScripts) score += 30;
      
      return {
        id: 'dependency-management',
        name: 'Dependency Management',
        category: 'structure',
        passed: score >= 70,
        score: score,
        message: `Dependency management score: ${score}%`
      };
    } catch (error) {
      return {
        id: 'dependency-management',
        name: 'Dependency Management',
        category: 'structure',
        passed: false,
        score: 0,
        message: 'Error parsing package.json'
      };
    }
  }

  // Documentation Tests
  private async runDocumentationTests(): Promise<QualityTest[]> {
    const tests: QualityTest[] = [];

    tests.push(await this.checkDocumentationCompleteness());
    tests.push(await this.checkDocumentationQuality());
    tests.push(await this.checkCodeComments());

    return tests;
  }

  private async checkDocumentationCompleteness(): Promise<QualityTest> {
    const requiredDocs = [
      'README.md',
      'SECURITY.md',
      'COMPLIANCE.md',
      'docs/architecture.md'
    ];
    
    const existingDocs = requiredDocs.filter(doc => 
      fs.existsSync(path.join(process.cwd(), doc))
    );
    
    const score = Math.round((existingDocs.length / requiredDocs.length) * 100);
    
    return {
      id: 'documentation-completeness',
      name: 'Documentation Completeness',
      category: 'documentation',
      passed: score >= 80,
      score: score,
      message: `${existingDocs.length}/${requiredDocs.length} required documents found`
    };
  }

  private async checkDocumentationQuality(): Promise<QualityTest> {
    const docs = ['README.md', 'SECURITY.md', 'COMPLIANCE.md'];
    let qualityScore = 0;
    let checkedDocs = 0;

    for (const doc of docs) {
      const docPath = path.join(process.cwd(), doc);
      if (!fs.existsSync(docPath)) continue;
      
      checkedDocs++;
      const content = fs.readFileSync(docPath, 'utf8');
      
      // Check documentation quality metrics
      const hasHeadings = (content.match(/^#/gm) || []).length >= 3;
      const hasCodeBlocks = content.includes('```');
      const hasLinks = content.includes('[') && content.includes(']');
      const isSubstantial = content.length >= 500;
      
      let docScore = 0;
      if (hasHeadings) docScore += 25;
      if (hasCodeBlocks) docScore += 25;
      if (hasLinks) docScore += 25;
      if (isSubstantial) docScore += 25;
      
      qualityScore += docScore;
    }
    
    const averageScore = checkedDocs > 0 ? Math.round(qualityScore / checkedDocs) : 0;
    
    return {
      id: 'documentation-quality',
      name: 'Documentation Quality',
      category: 'documentation',
      passed: averageScore >= 70,
      score: averageScore,
      message: `Average documentation quality: ${averageScore}% across ${checkedDocs} documents`
    };
  }

  private async checkCodeComments(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    
    if (!fs.existsSync(srcDir)) {
      return {
        id: 'code-comments',
        name: 'Code Comments',
        category: 'documentation',
        passed: false,
        score: 0,
        message: 'Source directory not found'
      };
    }

    const tsFiles = this.findTypeScriptFiles(srcDir);
    let totalLines = 0;
    let commentLines = 0;

    for (const file of tsFiles) {
      const content = fs.readFileSync(file, 'utf8');
      const lines = content.split('\n');
      
      for (const line of lines) {
        totalLines++;
        const trimmed = line.trim();
        return trimmed.startsWith('//') ||
               trimmed.startsWith('/*') ||
               trimmed.startsWith('*') ||
               trimmed.includes('/**');
      };
      commentLines += lines.filter(line => isComment(line)).length;
    }
    
    const commentPercentage = totalLines > 0 ? Math.round((commentLines / totalLines) * 100) : 0;
    const score = Math.min(100, commentPercentage * 5); // 20% comments = 100% score
    
    return {
      id: 'code-comments',
      name: 'Code Comments',
      category: 'documentation',
      passed: score >= 60,
      score: score,
      message: `${commentPercentage}% of lines contain comments`
    };
  }

  // Security Tests
  private async runSecurityTests(): Promise<QualityTest[]> {
    const tests: QualityTest[] = [];

    tests.push(await this.checkEnvironmentVariableHandling());
    tests.push(await this.checkInputValidation());
    tests.push(await this.checkErrorHandling());

    return tests;
  }

  private async checkEnvironmentVariableHandling(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    const tsFiles = this.findTypeScriptFiles(srcDir);
    let totalEnvUsage = 0;
    let secureHandling = 0;

    for (const file of tsFiles) {
      const content = fs.readFileSync(file, 'utf8');
      
      // Find environment variable usage
      const envMatches = content.match(/process\.env\.\w+/g) || [];
      totalEnvUsage += envMatches.length;
      
      // Check for secure handling (default values or validation)
      const hasDefaultValues = content.includes('process.env.') && content.includes('||');
      const hasValidation = content.includes('process.env.') && (content.includes('throw') || content.includes('Error'));
      
      if (hasDefaultValues || hasValidation) {
        secureHandling++;
      }
    }
    
    const score = totalEnvUsage > 0 ? Math.round((secureHandling / tsFiles.length) * 100) : 100;
    
    return {
      id: 'env-variable-handling',
      name: 'Environment Variable Handling',
      category: 'security',
      passed: score >= 80,
      score: score,
      message: `${secureHandling}/${tsFiles.length} files handle environment variables securely`
    };
  }

  private async checkInputValidation(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    const tsFiles = this.findTypeScriptFiles(srcDir);
    let inputHandlingFiles = 0;
    let validationCount = 0;

    for (const file of tsFiles) {
      const content = fs.readFileSync(file, 'utf8');
      
      // Check if file handles inputs
      const hasInputs = content.includes('args') ||
                       content.includes('req.') ||
                       content.includes('params') ||
                       content.includes('query');
      
      if (hasInputs) {
        inputHandlingFiles++;
        
        // Check for validation
        const hasValidation = content.includes('validate') ||
                             content.includes('sanitize') ||
                             content.includes('typeof') ||
                             content.includes('instanceof') ||
                             content.includes('Array.isArray');
        
        if (hasValidation) {
          validationCount++;
        }
      }
    }
    
    const score = inputHandlingFiles > 0 ? Math.round((validationCount / inputHandlingFiles) * 100) : 100;
    
    return {
      id: 'input-validation',
      name: 'Input Validation',
      category: 'security',
      passed: score >= 80,
      score: score,
      message: `${validationCount}/${inputHandlingFiles} input-handling files include validation`
    };
  }

  private async checkErrorHandling(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    const tsFiles = this.findTypeScriptFiles(srcDir);
    let properErrorHandling = 0;

    for (const file of tsFiles) {
      const content = fs.readFileSync(file, 'utf8');
      
      const hasTryCatch = content.includes('try {') && content.includes('catch');
      const hasErrorTypes = content.includes('Error') || content.includes('throw');
      const hasLogging = content.includes('console.error') || content.includes('logger');
      
      if (hasTryCatch && hasErrorTypes && hasLogging) {
        properErrorHandling++;
      }
    }
    
    const score = tsFiles.length > 0 ? Math.round((properErrorHandling / tsFiles.length) * 100) : 0;
    
    return {
      id: 'error-handling',
      name: 'Error Handling',
      category: 'security',
      passed: score >= 70,
      score: score,
      message: `${properErrorHandling}/${tsFiles.length} files have proper error handling`
    };
  }

  // Performance Tests
  private async runPerformanceTests(): Promise<QualityTest[]> {
    const tests: QualityTest[] = [];

    tests.push(await this.checkAsyncUsage());
    tests.push(await this.checkMemoryEfficiency());

    return tests;
  }

  private async checkAsyncUsage(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    const tsFiles = this.findTypeScriptFiles(srcDir);
    let asyncMethods = 0;
    let properAsyncUsage = 0;

    for (const file of tsFiles) {
      const content = fs.readFileSync(file, 'utf8');
      
      // Find async methods
      const asyncMatches = content.match(/async\s+\w+/g) || [];
      asyncMethods += asyncMatches.length;
      
      // Check for proper await usage
      const awaitMatches = content.match(/await\s+/g) || [];
      const hasPromiseAll = content.includes('Promise.all');
      
      if (awaitMatches.length > 0 || hasPromiseAll) {
        properAsyncUsage++;
      }
    }
    
    const score = asyncMethods > 0 ? Math.round((properAsyncUsage / tsFiles.length) * 100) : 100;
    
    return {
      id: 'async-usage',
      name: 'Async/Await Usage',
      category: 'performance',
      passed: score >= 80,
      score: score,
      message: `${properAsyncUsage}/${tsFiles.length} files use async/await properly`
    };
  }

  private async checkMemoryEfficiency(): Promise<QualityTest> {
    const srcDir = path.join(process.cwd(), 'src');
    const tsFiles = this.findTypeScriptFiles(srcDir);
    let memoryEfficientFiles = 0;

    for (const file of tsFiles) {
      const content = fs.readFileSync(file, 'utf8');
      
      // Check for memory-efficient patterns
      const hasStreaming = content.includes('stream') || content.includes('pipe');
      const avoidsLargeArrays = !content.includes('map(') || content.includes('filter(');
      const hasCleanup = content.includes('delete ') || content.includes('null');
      
      if (hasStreaming || avoidsLargeArrays || hasCleanup) {
        memoryEfficientFiles++;
      }
    }
    
    const score = tsFiles.length > 0 ? Math.round((memoryEfficientFiles / tsFiles.length) * 100) : 100;
    
    return {
      id: 'memory-efficiency',
      name: 'Memory Efficiency',
      category: 'performance',
      passed: score >= 70,
      score: score,
      message: `${memoryEfficientFiles}/${tsFiles.length} files show memory-efficient patterns`
    };
  }

  // Feature validation methods
  private async validateFeatureCategory(category: string): Promise<CategoryValidation> {
    const features = await this.getExpectedFeatures(category);
    const implementedFeatures = await this.getImplementedFeatures(category);
    
    const completeness = features.length > 0 ? 
      Math.round((implementedFeatures.length / features.length) * 100) : 100;
    
    return {
      category: category,
      completeness: completeness,
      tests: [], // Will be populated by specific tests
      missingFeatures: features.filter(f => !implementedFeatures.includes(f)),
      implementationGaps: [
        `${features.length - implementedFeatures.length} features missing`,
        `${completeness}% completion rate`
      ]
    };
  }

  private async getExpectedFeatures(category: string): Promise<string[]> {
    const featureMap: Record<string, string[]> = {
      core_agents: [
        'ComplianceAgent',
        'AuditAgent', 
        'RiskAgent',
        'SecurityAgent',
        'MonitoringAgent'
      ],
      monitoring_system: [
        'Real-time monitoring',
        'Alert management',
        'Performance tracking',
        'System health checks'
      ],
      compliance_validation: [
        'SOC2 validation',
        'Evidence collection',
        'Control testing',
        'Reporting'
      ],
      security_controls: [
        'Access controls',
        'Data protection',
        'Encryption',
        'Vulnerability management'
      ],
      audit_preparation: [
        'Documentation generation',
        'Evidence packaging',
        'Readiness assessment',
        'Gap analysis'
      ]
    };
    
    return featureMap[category] || [];
  }

  private async getImplementedFeatures(category: string): Promise<string[]> {
    if (category === 'core_agents') {
      const agentsDir = path.join(process.cwd(), 'src', 'agents');
      if (fs.existsSync(agentsDir)) {
        const agentFiles = fs.readdirSync(agentsDir)
          .filter(file => file.endsWith('.ts'))
          .map(file => file.replace('.ts', ''));
        return agentFiles;
      }
    }
    
    // For other categories, return placeholder implementation
    return [];
  }

  // Security audit methods
  private async runAPISecurityChecks(): Promise<SecurityCheck[]> {
    // Implementation for API security checks
    return [];
  }

  private async runDataProtectionChecks(): Promise<SecurityCheck[]> {
    // Implementation for data protection checks
    return [];
  }

  private async runAccessControlChecks(): Promise<SecurityCheck[]> {
    // Implementation for access control checks
    return [];
  }

  private async runVulnerabilityChecks(): Promise<SecurityCheck[]> {
    // Implementation for vulnerability checks
    return [];
  }

  // Performance testing methods
  private async runAgentPerformanceTests(): Promise<PerformanceTest[]> {
    // Implementation for agent performance tests
    return [];
  }

  private async runMemoryUsageTests(): Promise<PerformanceTest[]> {
    // Implementation for memory usage tests
    return [];
  }

  private async runScalabilityTests(): Promise<PerformanceTest[]> {
    // Implementation for scalability tests
    return [];
  }

  private async runResponseTimeTests(): Promise<PerformanceTest[]> {
    // Implementation for response time tests
    return [];
  }

  // Utility methods
  private findTypeScriptFiles(dir: string): string[] {
    const files: string[] = [];
    
    try {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          files.push(...this.findTypeScriptFiles(fullPath));
        } else if (item.endsWith('.ts')) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      // Directory access error, continue
    }
    
    return files;
  }

  private calculateOverallScore(tests: QualityTest[]): number {
    if (tests.length === 0) return 0;
    
    const totalScore = tests.reduce((sum, test) => sum + test.score, 0);
    return Math.round(totalScore / tests.length);
  }

  private calculateOverallCompleteness(validations: CategoryValidation[]): number {
    if (validations.length === 0) return 0;
    
    const totalCompletion = validations.reduce((sum, v) => sum + v.completeness, 0);
    return Math.round(totalCompletion / validations.length);
  }

  private calculateSecurityScore(checks: SecurityCheck[]): number {
    if (checks.length === 0) return 100;
    
    const passedChecks = checks.filter(c => c.passed).length;
    return Math.round((passedChecks / checks.length) * 100);
  }

  private calculatePerformanceScore(tests: PerformanceTest[]): number {
    if (tests.length === 0) return 100;
    
    const totalScore = tests.reduce((sum, test) => sum + test.score, 0);
    return Math.round(totalScore / tests.length);
  }

  private identifyMissingFeatures(validations: CategoryValidation[]): string[] {
    return validations.flatMap(v => v.missingFeatures);
  }

  private identifyImplementationGaps(validations: CategoryValidation[]): string[] {
    return validations
      .filter(v => v.completeness < 100)
      .map(v => `${v.category}: ${100 - v.completeness}% incomplete`);
  }

  private identifyVulnerabilities(checks: SecurityCheck[]): SecurityCheck[] {
    return checks.filter(c => !c.passed);
  }

  private identifyOptimizationOpportunities(tests: PerformanceTest[]): string[] {
    return tests
      .filter(t => t.score < 90)
      .map(t => `Optimize ${t.name}: Current score ${t.score}%`);
  }

  private generatePerformanceBenchmarks(tests: PerformanceTest[]): Record<string, string> {
    const benchmarks: Record<string, string> = {};
    
    for (const test of tests) {
      benchmarks[test.id] = `${test.benchmark} (actual: ${test.actual})`;
    }
    
    return benchmarks;
  }

  private async generateQualityRecommendations(tests: QualityTest[]): Promise<string[]> {
    const recommendations: string[] = [];
    const failedTests = tests.filter(t => !t.passed);
    
    for (const test of failedTests) {
      switch (test.category) {
        case 'typescript':
          recommendations.push(`Improve TypeScript quality: ${test.message}`);
          break;
        case 'structure':
          recommendations.push(`Fix code structure: ${test.message}`);
          break;
        case 'documentation':
          recommendations.push(`Enhance documentation: ${test.message}`);
          break;
        case 'security':
          recommendations.push(`Address security issue: ${test.message}`);
          break;
        case 'performance':
          recommendations.push(`Optimize performance: ${test.message}`);
          break;
      }
    }
    
    return recommendations;
  }

  private async generateSecurityRecommendations(checks: SecurityCheck[]): Promise<string[]> {
    const failedChecks = checks.filter(c => !c.passed);
    const recommendations: string[] = [];
    
    for (const check of failedChecks) {
      recommendations.push(`Fix ${check.severity} security issue: ${check.message}`);
    }
    
    return recommendations;
  }

  private calculateQualityMetrics(tests: QualityTest[]): QualityMetrics {
    const categoryBreakdown = tests.reduce((acc, test) => {
      if (!acc[test.category]) {
        acc[test.category] = { total: 0, passed: 0, avgScore: 0 };
      }
      acc[test.category].total++;
      if (test.passed) acc[test.category].passed++;
      acc[test.category].avgScore += test.score;
    }, {} as Record<string, { total: number; passed: number; avgScore: number }>);

    // Calculate average scores
    Object.keys(categoryBreakdown).forEach(category => {
      categoryBreakdown[category].avgScore = Math.round(categoryBreakdown[category].avgScore / categoryBreakdown[category].total);
    });

    return {
      totalTests: tests.length,
      passedTests: tests.filter(t => t.passed).length,
      failedTests: tests.filter(t => !t.passed).length,
      averageScore: this.calculateOverallScore(tests),
      categoryBreakdown: categoryBreakdown
    };
  }

  private generateQualityBenchmarks(tests: QualityTest[]): Record<string, string> {
    const benchmarks: Record<string, string> = {};
    
    for (const test of tests) {
      if (test.benchmark) {
        benchmarks[test.id] = test.benchmark;
      }
    }
    
    return benchmarks;
  }

  // File saving methods
  private async saveQualityReport(report: QualityReport): Promise<void> {
    const fileName = `quality_report_${Date.now()}.json`;
    const filePath = path.join(this.outputDir, fileName);

    fs.writeFileSync(filePath, JSON.stringify(report, null, 2));
    console.log(`‚úÖ Quality report saved: ${filePath}`);

    // Also save as markdown
    const markdownReport = this.generateQualityMarkdownReport(report);
    const markdownPath = path.join(this.outputDir, 'quality_report.md');
    fs.writeFileSync(markdownPath, markdownReport);
    console.log(`üìã Quality report (MD) saved: ${markdownPath}`);
  }

  private async saveFeatureValidation(validation: FeatureValidation): Promise<void> {
    const fileName = `feature_validation_${Date.now()}.json`;
    const filePath = path.join(this.outputDir, fileName);

    fs.writeFileSync(filePath, JSON.stringify(validation, null, 2));
    console.log(`‚úÖ Feature validation saved: ${filePath}`);
  }

  private async saveSecurityAudit(audit: SecurityAuditResult): Promise<void> {
    const fileName = `security_audit_${Date.now()}.json`;
    const filePath = path.join(this.outputDir, fileName);

    fs.writeFileSync(filePath, JSON.stringify(audit, null, 2));
    console.log(`‚úÖ Security audit saved: ${filePath}`);
  }

  private async savePerformanceReport(report: PerformanceReport): Promise<void> {
    const fileName = `performance_report_${Date.now()}.json`;
    const filePath = path.join(this.outputDir, fileName);

    fs.writeFileSync(filePath, JSON.stringify(report, null, 2));
    console.log(`‚úÖ Performance report saved: ${filePath}`);
  }

    private generateQualityMarkdownReport(report: QualityReport): string {
    return `# Quality Assurance Report

**Timestamp:** ${report.timestamp}
**Overall Score:** ${report.overallScore}%

## Summary

- **Total Tests:** ${report.metrics.totalTests}
- **Passed:** ${report.metrics.passedTests}
- **Failed:** ${report.metrics.failedTests}
- **Pass Rate:** ${Math.round((report.metrics.passedTests / report.metrics.totalTests) * 100)}%

## Test Results by Category

${Object.entries(report.metrics.categoryBreakdown).map(([category, metrics]) => `
### ${category.charAt(0).toUpperCase() + category.slice(1)}
- **Total Tests:** ${metrics.total}
- **Passed:** ${metrics.passed}
- **Average Score:** ${metrics.avgScore}%
`).join('')}

## Failed Tests

${report.tests.filter(t => !t.passed).map(test => `
- **${test.name}**: ${test.message} (Score: ${test.score}%)
`).join('')}

## Recommendations

${report.recommendations.map(r => `- ${r}`).join('\n')}

---

*Generated by Quality Assurance Agent*`;
  }
}

// CLI interface
async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || 'quality';

  try {
    const agent = new QualityAssuranceAgent();

    switch (command) {
      case 'quality':
        console.log('üîç Running quality assurance tests...');
        const qualityReport = await agent.runCodeQualityTests();
        console.log(`\nüìä Quality Score: ${qualityReport.overallScore}%`);
        break;

      case 'features':
        console.log('üìã Validating feature completeness...');
        const featureValidation = await agent.validateFeatureCompleteness();
        console.log(`\nüìä Overall Completeness: ${featureValidation.overallCompleteness}%`);
        break;

      case 'security':
        console.log('üîí Performing security audit...');
        const securityAudit = await agent.performSecurityAudit();
        console.log(`\nüìä Security Score: ${securityAudit.overallSecurityScore}%`);
        break;

      case 'performance':
        console.log('‚ö° Checking performance metrics...');
        const performanceReport = await agent.checkPerformanceMetrics();
        console.log(`\nüìä Performance Score: ${performanceReport.overallPerformanceScore}%`);
        break;

      case 'all':
        console.log('üöÄ Running comprehensive quality assessment...');
        const [quality, features, security, performance] = await Promise.all([
          agent.runCodeQualityTests(),
          agent.validateFeatureCompleteness(),
          agent.performSecurityAudit(),
          agent.checkPerformanceMetrics()
        ]);
        
        console.log('\nüìä QA Summary:');
        console.log(`Quality Score: ${quality.overallScore}%`);
        console.log(`Feature Completeness: ${features.overallCompleteness}%`);
        console.log(`Security Score: ${security.overallSecurityScore}%`);
        console.log(`Performance Score: ${performance.overallPerformanceScore}%`);
        break;

      default:
        console.log('Usage: npm run qa [quality|features|security|performance|all]');
        process.exit(1);
    }

    console.log('\n‚úÖ Quality assurance completed successfully!');
  } catch (error) {
    console.error('‚ùå Quality assurance failed:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

export { QualityAssuranceAgent };
